<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>3D First-Person Snake Game</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #333; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 20px sans-serif;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 4px;
      z-index: 10;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font: 24px sans-serif;
      color: #fff;
      background: rgba(0,0,0,0.8);
      cursor: pointer;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="overlay">
    Click to Play<br>
    Hold â†‘ to move
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // === Configuration constants ===
    const planeSize = 400;            // play area size
    const snakeSpeed = 0.2;
    const turnSpeed = Math.PI / 120;  // turning speed

    let scene, camera, renderer;
    let snake = [], positions = [];
    let headMesh, food, score = 0;
    let direction = new THREE.Vector3(0, 0, -1);
    let moveForward = false; // only move when ArrowUp is held

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      // grid floor
      const grid = new THREE.GridHelper(planeSize, planeSize, 0x888888, 0x444444);
      scene.add(grid);

      // axes helper
      scene.add(new THREE.AxesHelper(5));

      // camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        planeSize * 2
      );
      camera.position.set(0, 2, 0);
      camera.rotation.x = -0.2;

      // lights
      scene.add(new THREE.AmbientLight(0x808080));
      const dlight = new THREE.DirectionalLight(0xffffff, 1);
      dlight.position.set(5, 10, 7.5);
      scene.add(dlight);

      // head mesh (semi-transparent cube)
      const headGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      headMesh = new THREE.Mesh(headGeo, headMat);
      headMesh.position.set(0, 0, -0.5);
      camera.add(headMesh);

      // initial snake body segments
      const segGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const segMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
      for (let i = 0; i < 5; i++) {
        const seg = new THREE.Mesh(segGeo, segMat);
        seg.position.set(0, 0.25, i * 0.6);
        scene.add(seg);
        snake.push(seg);
        positions.push(seg.position.clone());
      }
      // one extra history slot
      positions.push(camera.position.clone());

      // food
      const fGeo = new THREE.SphereGeometry(0.3, 16, 16);
      const fMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
      food = new THREE.Mesh(fGeo, fMat);
      placeFood();
      scene.add(food);

      // renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.setAttribute('tabindex', '0');
      renderer.domElement.style.outline = 'none';
      document.body.appendChild(renderer.domElement);
      renderer.domElement.focus();

      // event listeners
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.getElementById('overlay').addEventListener('click', () => {
        document.getElementById('overlay').style.display = 'none';
        renderer.domElement.focus();
      });
    }

    function placeFood() {
      const range = planeSize / 2;
      const y = camera.position.y;
      food.position.set(
        (Math.random() - 0.5) * range,
        y,
        (Math.random() - 0.5) * range
      );
    }

    function onKeyDown(e) {
      switch (e.code) {
        case 'ArrowLeft':
          camera.rotation.y += turnSpeed;
          direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), turnSpeed);
          break;
        case 'ArrowRight':
          camera.rotation.y -= turnSpeed;
          direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), -turnSpeed);
          break;
        case 'ArrowUp':
          moveForward = true;
          break;
        case 'ArrowDown':
          // optional: could add backward movement
          break;
      }
    }

    function onKeyUp(e) {
      if (e.code === 'ArrowUp') {
        moveForward = false;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      // only advance when holding forward
      if (moveForward) {
        camera.position.addScaledVector(direction, snakeSpeed);
        positions.unshift(camera.position.clone());
        positions.pop();
      }

      // update snake segments
      snake.forEach((seg, i) => {
        const target = positions[i + 1];
        if (target) seg.position.copy(target);
      });

      // check for food collision (horizontal plane)
      const dx = camera.position.x - food.position.x;
      const dz = camera.position.z - food.position.z;
      if (Math.hypot(dx, dz) < 0.5) {
        score++;
        document.getElementById('score').innerText = 'Score: ' + score;
        flashHead();
        growSnake();
        placeFood();
      }

      renderer.render(scene, camera);
    }

    function flashHead() {
      headMesh.material.color.set(0xffff00);
      setTimeout(() => headMesh.material.color.set(0xffffff), 100);
    }

    function growSnake() {
      const segGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const segMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
      const seg = new THREE.Mesh(segGeo, segMat);
      const lastPos = positions[positions.length - 1];
      seg.position.copy(lastPos || camera.position);
      scene.add(seg);
      snake.push(seg);
      positions.push(seg.position.clone());
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>